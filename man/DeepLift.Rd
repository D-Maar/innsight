% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DeepLift.R
\name{DeepLift}
\alias{DeepLift}
\title{Deep Learning Important FeaTures (DeepLift)}
\description{
This is an implementation of the \emph{Deep Learning Important FeaTures
(DeepLift)} algorithm introduced by Shrikumar et al. (2017). It's a local
method for interpreting a single element \eqn{x} of the dataset concerning
a reference value \eqn{x'} and returns the contribution of each input
feature from the difference of the output (\eqn{y=f(x)}) and reference
output (\eqn{y'=f(x')}) prediction. The basic idea of this method is to
decompose the difference-from-reference prediction with respect to the
input features, i.e.
\deqn{\Delta y = y - y'  = \sum_i C(x_i).}
Compared to \emph{Layer-wise Relevance Propagation} (see \link{LRP}), the
DeepLift method is an exact decomposition and not an approximation, so we
get real contributions of the input features to the
difference-from-reference prediction. There are two ways to handle
activation functions: \emph{Rescale-Rule} (\code{'rescale'}) and
\emph{RevealCancel-Rule} (\code{'reveal_cancel'}).
}
\examples{
\dontshow{if (torch::torch_is_installed()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
#----------------------- Example 1: Torch ----------------------------------
library(torch)

# Create nn_sequential model and data
model <- nn_sequential(
  nn_linear(5, 12),
  nn_relu(),
  nn_linear(12, 2),
  nn_softmax(dim = 2)
)
data <- torch_randn(25, 5)
ref <- torch_randn(1, 5)

# Create Converter
converter <- Converter$new(model, input_dim = c(5))

# Apply method DeepLift
deeplift <- DeepLift$new(converter, data, x_ref = ref)

# Print the result as a torch tensor for first two data points
deeplift$get_result("torch.tensor")[1:2]

# Plot the result for both classes
plot(deeplift, output_idx = 1:2)

# Plot the boxplot of all datapoints
boxplot(deeplift, output_idx = 1:2)

# ------------------------- Example 2: Neuralnet ---------------------------
library(neuralnet)
data(iris)

# Train a neural network
nn <- neuralnet((Species == "setosa") ~ Petal.Length + Petal.Width,
  iris,
  linear.output = FALSE,
  hidden = c(3, 2), act.fct = "tanh", rep = 1
)

# Convert the model
converter <- Converter$new(nn)

# Apply DeepLift with rescale-rule and a reference input of the feature
# means
x_ref <- matrix(colMeans(iris[, c(3, 4)]), nrow = 1)
deeplift_rescale <- DeepLift$new(converter, iris[, c(3, 4)], x_ref = x_ref)

# Get the result as a dataframe and show first 5 rows
deeplift_rescale$get_result(type = "data.frame")[1:5, ]

# Plot the result for the first datapoint in the data
plot(deeplift_rescale, data_idx = 1)

# Plot the result as boxplots
boxplot(deeplift_rescale)

# ------------------------- Example 3: Keras -------------------------------
library(keras)

if (is_keras_available()) {
  data <- array(rnorm(10 * 32 * 32 * 3), dim = c(10, 32, 32, 3))

  model <- keras_model_sequential()
  model \%>\%
    layer_conv_2d(
      input_shape = c(32, 32, 3), kernel_size = 8, filters = 8,
      activation = "softplus", padding = "valid"
    ) \%>\%
    layer_conv_2d(
      kernel_size = 8, filters = 4, activation = "tanh",
      padding = "same"
    ) \%>\%
    layer_conv_2d(
      kernel_size = 4, filters = 2, activation = "relu",
      padding = "valid"
    ) \%>\%
    layer_flatten() \%>\%
    layer_dense(units = 64, activation = "relu") \%>\%
    layer_dense(units = 16, activation = "relu") \%>\%
    layer_dense(units = 2, activation = "softmax")

  # Convert the model
  converter <- Converter$new(model)

  # Apply the DeepLift method with reveal-cancel rule
  deeplift_revcancel <- DeepLift$new(converter, data,
    channels_first = FALSE,
    rule_name = "reveal_cancel"
  )

  # Plot the result for the first image and both classes
  plot(deeplift_revcancel, output_idx = 1:2)

  # Plot the result as boxplots for first class
  boxplot(deeplift_revcancel, output_idx = 1)

  # You can also create an interactive plot with plotly.
  # This is a suggested package, so make sure that it is installed
  library(plotly)
  boxplot(deeplift_revcancel, as_plotly = TRUE)
}
\dontshow{\}) # examplesIf}
}
\references{
A. Shrikumar et al. (2017) \emph{Learning important features through
propagating activation differences.}  ICML 2017, p. 4844-4866
}
\seealso{
Other methods: 
\code{\link{ConnectionWeights}},
\code{\link{Gradient}},
\code{\link{LRP}},
\code{\link{SmoothGrad}}
}
\concept{methods}
\section{Super class}{
\code{\link[innsight:InterpretingMethod]{innsight::InterpretingMethod}} -> \code{DeepLift}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{x_ref}}{The reference input for the DeepLift method. This value has the same
format as the input data of the passed model to the converter object.
This means either
\itemize{
\item an \code{array}, \code{data.frame}, \code{torch_tensor} or array-like format of
size \emph{(1, dim_in)}, if e.g.the model has only one input layer, or
\item a \code{list} with the corresponding input data (according to the upper point)
for each of the input layers.
\item It is also possible to use the default value \code{NULL} to take only
zeros as reference input.
}}

\item{\code{rule_name}}{Name of the applied rule to calculate the contributions.
Either \code{'rescale'} or \code{'reveal_cancel'}.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{DeepLift$new()}}
\item \href{#method-plot}{\code{DeepLift$plot()}}
\item \href{#method-boxplot}{\code{DeepLift$boxplot()}}
\item \href{#method-clone}{\code{DeepLift$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="innsight" data-topic="InterpretingMethod" data-id="get_result">}\href{../../innsight/html/InterpretingMethod.html#method-get_result}{\code{innsight::InterpretingMethod$get_result()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new instance of the \emph{DeepLift} method. When initialized,
the method is applied to the given data and the results are stored in
the field \code{result}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$new(
  converter,
  data,
  channels_first = TRUE,
  output_idx = NULL,
  ignore_last_act = TRUE,
  rule_name = "rescale",
  x_ref = NULL,
  dtype = "float"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{converter}}{An instance of the \code{Converter} class that includes the
torch-converted model and some other model-specific attributes. See
\code{\link{Converter}} for details.}

\item{\code{data}}{The data to which the method is to be applied. These must
have the same format as the input data of the passed model to the
converter object. This means either
\itemize{
\item an \code{array}, \code{data.frame}, \code{torch_tensor} or array-like format of
size \emph{(batch_size, dim_in)}, if e.g.the model has only one input layer, or
\item a \code{list} with the corresponding input data (according to the
upper point) for each of the input layers.
}}

\item{\code{channels_first}}{The channel position of the given data (argument
\code{data}). If \code{TRUE}, the channel axis is placed at the second position
between the batch size and the rest of the input axes, e.g.
\code{c(10,3,32,32)} for a batch of ten images with three channels and a
height and width of 32 pixels. Otherwise (\code{FALSE}), the channel axis
is at the last position, i.e. \code{c(10,32,32,3)}. If the data
has no channel axis, use the default value \code{TRUE}.}

\item{\code{output_idx}}{These indices specify the output nodes for which
the method is to be applied. In order to allow models with multiple
output layers, there are the following possibilities to select
the indices of the output nodes in the individual output layers:
\itemize{
\item A \code{vector} of indices: If the model has only one output layer,
the values correspond to the indices of the output nodes, e.g.
\code{c(1,3,4)} for the first, third and fourth output node. If there are
multiple output layers, the indices of the output nodes from the first
output layer are considered.
\item A \code{list} of \code{vectors} of indices: If the method is to be
applied to output nodes from different layers, a list can be passed
that specifies the desired indices of the output nodes for each
output layer. Unwanted output layers have the entry \code{NULL} instead of
a vector of indices, e.g. \code{list(NULL, c(1,3))} for the first and
third output node in the second output layer.
\item \code{NULL} (default): The method is applied to all output nodes in
the first output layer but is limited to the first ten as the
calculations become more computationally expensive for more output
nodes.
}}

\item{\code{ignore_last_act}}{Set this logical value to include the last
activation functions for each output layer, or not (default: \code{TRUE}).
In practice, the last activation (especially for softmax activation) is
often omitted.}

\item{\code{rule_name}}{Name of the applied rule to calculate the
contributions. Use either \code{'rescale'} or \code{'reveal_cancel'}.}

\item{\code{x_ref}}{The reference input for the DeepLift method. This value
must have the same format as the input data of the passed model to the
converter object. This means either
\itemize{
\item an \code{array}, \code{data.frame}, \code{torch_tensor} or array-like format of
size \emph{(1, dim_in)}, if e.g.the model has only one input layer, or
\item a \code{list} with the corresponding input data (according to the upper point)
for each of the input layers.
\item It is also possible to use the default value \code{NULL} to take only
zeros as reference input.
}}

\item{\code{dtype}}{The data type for the calculations. Use
either \code{'float'} for \link[torch:torch_dtype]{torch::torch_float} or \code{'double'} for
\link[torch:torch_dtype]{torch::torch_double}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
This method visualizes the result of individual data points of the
selected method and enables a visual in-depth investigation with the help
of the S4 classes \code{\link{innsight_ggplot2}} and \code{\link{innsight_plotly}}.\cr
You can use the argument \code{data_idx} to select the data points in the
given data for the plot. In addition, the individual output nodes for
the plot can be selected with the argument \code{output_idx}. The different
results for the selected data points and outputs are visualized using
the ggplot2-based S4 class \code{innsight_ggplot2}. You can also use the
\code{as_plotly} argument to generate an interactive plot with
\code{innsight_plotly} based on the plot function \link[plotly:plot_ly]{plotly::plot_ly}. For
more information and the whole bunch of possibilities, see
\code{\link{innsight_ggplot2}} and \code{\link{innsight_plotly}}.\cr
\cr
\strong{Note:}
\enumerate{
\item For the interactive plotly-based plots, the suggested package
\code{plotly} is required.
\item The ggplot2-based plots for models with multiple input layers are
a bit more complex, therefore the suggested packages \code{'grid'},
\code{'gridExtra'} and \code{'gtable'} must be installed in your R session.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$plot(
  data_idx = 1,
  output_idx = NULL,
  aggr_channels = "sum",
  as_plotly = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data_idx}}{An integer vector containing the numbers of the data
points whose result is to be plotted, e.g. \code{c(1,3)} for the first
and third data point in the given data. Default: \code{1}.}

\item{\code{output_idx}}{The indices of the output nodes for which the results
is to be plotted. This can be either a \code{vector} of indices or a
\code{list} of vectors of indices but must be a subset of the indices
for which the results were calculated, i.e. a subset of \code{output_idx}
from the initialization \code{new()} (see argument \code{output_idx} in
method \code{new()} of this R6 class for details). By default (\code{NULL}),
the smallest index of all calculated output nodes and output layers
is used.}

\item{\code{aggr_channels}}{Pass one of \code{'norm'}, \code{'sum'}, \code{'mean'} or a
custom function to aggregate the channels, e.g. the maximum
(\link[base:Extremes]{base::max}) or minimum (\link[base:Extremes]{base::min}) over the channels or only
individual channels with \code{function(x) x[1]}. By default (\code{'sum'}),
the sum of all channels is used.\cr
\emph{Note:} This argument is used only for 2D and 3D input data.}

\item{\code{as_plotly}}{This logical value (default: \code{FALSE}) can be used to
create an interactive plot based on the library \code{plotly}
(see \code{\link{innsight_plotly}} for details).\cr
\emph{Note:} Make sure that the suggested package \code{plotly} is installed
in your R session.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns either an \code{\link{innsight_ggplot2}} (\code{as_plotly = FALSE}) or an
\code{\link{innsight_plotly}} (\code{as_plotly = TRUE}) object with the plotted
individual results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-boxplot"></a>}}
\if{latex}{\out{\hypertarget{method-boxplot}{}}}
\subsection{Method \code{boxplot()}}{
This method visualizes the results of the selected method summarized as
boxplots and enables a visual in-depth investigation of the global
behavior with the help of the S4 classes \code{\link{innsight_ggplot2}} and
\code{\link{innsight_plotly}}.\cr
You can use the argument \code{output_idx} to select the individual output
nodes for the plot. For tabular and 1D data, boxplots are created in
which a reference value can be selected from the data using the
\code{ref_data_idx} argument. For images, only the pixel-wise median is
visualized due to the complexity. The plot is generated using the
ggplot2-based S4 class \code{innsight_ggplot2}. You can also use the
\code{as_plotly} argument to generate an interactive plot with
\code{innsight_plotly} based on the plot function \link[plotly:plot_ly]{plotly::plot_ly}. For
more information and the whole bunch of possibilities, see
\code{\link{innsight_ggplot2}} and \code{\link{innsight_plotly}}.\cr \cr
\strong{Note:}
\enumerate{
\item For the interactive plotly-based plots, the suggested package
\code{plotly} is required.
\item The ggplot2-based plots for models with multiple input layers are
a bit more complex, therefore the suggested packages \code{'grid'},
\code{'gridExtra'} and \code{'gtable'} must be installed in your R session.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$boxplot(
  output_idx = NULL,
  data_idx = "all",
  ref_data_idx = NULL,
  aggr_channels = "sum",
  preprocess_FUN = abs,
  as_plotly = FALSE,
  individual_data_idx = NULL,
  individual_max = 20
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{output_idx}}{The indices of the output nodes for which the
results is to be plotted. This can be either a \code{vector} of indices or
a \code{list} of vectors of indices but must be a subset of the indices
for which the results were calculated, i.e. a subset of \code{output_idx}
from the initialization \code{new()} (see argument \code{output_idx} in method
\code{new()} of this R6 class for details). By default (\code{NULL}), the
smallest index of all calculated output nodes and output layers is used.}

\item{\code{data_idx}}{By default ("all"), all available data points are used
to calculate the boxplot information. However, this parameter can be
used to select a subset of them by passing the indices. E.g. with
\code{c(1:10, 25, 26)} only the first 10 data points and
the 25th and 26th are used to calculate the boxplots.}

\item{\code{ref_data_idx}}{This integer number determines the index for the
reference data point. In addition to the boxplots, it is displayed in
red color and is used to compare an individual result with the summary
statistics provided by the boxplot. With the default value (\code{NULL})
no individual data point is plotted. This index can be chosen with
respect to all available data, even if only a subset is selected with
argument \code{data_idx}.\cr
\emph{Note:} Because of the complexity of 2D inputs, this argument is used
only for tabular and 1D inputs and disregarded for 2D inputs.}

\item{\code{aggr_channels}}{Pass one of \code{'norm'}, \code{'sum'}, \code{'mean'} or a
custom function to aggregate the channels, e.g. the maximum
(\link[base:Extremes]{base::max}) or minimum (\link[base:Extremes]{base::min}) over the channels or only
individual channels with \code{function(x) x[1]}. By default (\code{'sum'}),
the sum of all channels is used.\cr
\emph{Note:} This argument is used only for 2D and 3D input data.}

\item{\code{preprocess_FUN}}{This function is applied to the method's result
before calculating the boxplots or medians. Since positive and negative values
often cancel each other out, the absolute value (\code{abs}) is used by
default. But you can also use the raw results (\code{identity}) to see the
results' orientation, the squared data (\code{function(x) x^2}) to weight
the outliers higher or any other function.}

\item{\code{as_plotly}}{This logical value (default: \code{FALSE}) can be used to
create an interactive plot based on the library \code{plotly}
(see \code{\link{innsight_plotly}} for details).\cr
\emph{Note:} Make sure that the suggested package \code{plotly} is installed
in your R session.}

\item{\code{individual_data_idx}}{Only relevant for a \code{plotly} plot with tabular
or 1D inputs! This integer vector of data indices determines
the available data points in a dropdown menu, which are drawn in
individually analogous to \code{ref_data_idx} only for more data points.
With the default value \code{NULL} the first \code{individual_max} data points
are used.\cr
\emph{Note:} If \code{ref_data_idx} is specified, this data point will be
added to those from \code{individual_data_idx} in the dropdown menu.}

\item{\code{individual_max}}{Only relevant for a \code{plotly} plot with tabular or
1D inputs! This integer determines the maximum number of
individual data points in the dropdown menu without counting
\code{ref_data_idx}. This means that if \code{individual_data_idx} has more
than \code{individual_max} indices, only the first \code{individual_max} will
be used. A too high number can significantly increase the runtime.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns either an \code{\link{innsight_ggplot2}} (\code{as_plotly = FALSE}) or an
\code{\link{innsight_plotly}} (\code{as_plotly = TRUE}) object with the plotted
summarized results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
