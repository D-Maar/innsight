% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LRP.R
\name{LRP}
\alias{LRP}
\title{Layer-wise Relevance Propagation (LRP) Method}
\description{
This is an implementation of the \emph{Layer-wise Relevance Propagation
(LRP)} algorithm introduced by Bach et al. (2015). It's a local method for
interpreting a single element of the dataset and calculates the relevance
scores for each input feature. The basic idea of this method is to decompose
the prediction score of the model with respect to the input features, i.e.
\deqn{f(x) = \sum_i R(x_i).}
Because of the bias vector, this decomposition is generally an approximation.
There exist several propagation rules to determine the relevance scores.
In this package are implemented: simple rule ("simple"), epsilon rule
("epsilon") and alpha-beta rule ("alpha_beta").
}
\examples{
library(neuralnet)
data(iris)
nn <- neuralnet(Species ~ .,
  iris,
  linear.output = FALSE,
  hidden = c(10, 8), act.fct = "tanh", rep = 1, threshold = 0.5
)
# create an converter for this model
converter <- Converter$new(nn)

# create new instance of 'LRP'
lrp <- LRP$new(converter, iris[, -5], rule_name = "simple")

# get the result as an array
lrp$get_result()

# get the result as a torch tensor
lrp$get_result(type = "torch.tensor")

# use the alpha-beta rule with alpha = 2
lrp <- LRP$new(converter, iris[, -5],
  rule_name = "alpha_beta",
  rule_param = 2
)

# include the last activation into the calculation
lrp <- LRP$new(converter, iris[, -5],
  rule_name = "alpha_beta",
  rule_param = 2,
  ignore_last_act = FALSE
)
}
\references{
S. Bach et al. (2015) \emph{On pixel-wise explanations for non-linear
classifier decisions by layer-wise relevance propagation.} PLoS ONE 10,
p. 1-46
}
\section{Super class}{
\code{\link[innsight:InterpretingMethod]{innsight::InterpretingMethod}} -> \code{LRP}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{rule_name}}{The name of the rule, with which the relevance scores
are calculated. Implemented are \code{"simple"}, \code{"epsilon"},
\code{"alpha_beta"} (default: \code{"simple"}).}

\item{\code{rule_param}}{The parameter of the selected rule.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{LRP$new()}}
\item \href{#method-clone}{\code{LRP$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="innsight" data-topic="InterpretingMethod" data-id="get_result">}\href{../../innsight/html/InterpretingMethod.html#method-get_result}{\code{innsight::InterpretingMethod$get_result()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="innsight" data-topic="InterpretingMethod" data-id="plot">}\href{../../innsight/html/InterpretingMethod.html#method-plot}{\code{innsight::InterpretingMethod$plot()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new instance of the LRP-Method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{LRP$new(
  converter,
  data,
  channels_first = TRUE,
  rule_name = "simple",
  rule_param = NULL,
  ignore_last_act = TRUE,
  dtype = "float"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{converter}}{An instance of the R6 class \code{\link{Converter}}.}

\item{\code{data}}{The data for which the relevance scores are to be
calculated. It has to be an array or array-like format of size
(batch_size, dim_in).}

\item{\code{channels_first}}{Set the data format of the given data. Internally
the format \code{channels_first} is used, therefore the format of the given
data is required. Also use the default value \code{TRUE} if no convolutional
layers are used.}

\item{\code{rule_name}}{The name of the rule, with which the relevance scores
are calculated. Implemented are \code{"simple"}, \code{"epsilon"},
\code{"alpha_beta"} (default: \code{"simple"}).}

\item{\code{rule_param}}{The parameter of the selected rule. Note: Only the
rules \code{"epsilon"} and \code{"alpha_beta"} take use of the
parameter. Use the default value \code{NULL} for the default parameters
("epsilon" : \eqn{0.01}, "alpha_beta" : \eqn{0.5}).}

\item{\code{ignore_last_act}}{Set this boolean value to include the last
activation, or not (default: \code{TRUE}). In some cases, the last activation
leads to a saturation problem.}

\item{\code{dtype}}{The data type for the calculations. Use either \code{'float'} or
\code{'double'}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new instance of the R6 class \code{'LRP'}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{LRP$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
