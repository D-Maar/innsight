% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ConnectionWeights.R
\name{ConnectionWeights}
\alias{ConnectionWeights}
\title{Connection Weights Method}
\description{
This class implements the \emph{Connection Weight} method investigated by
Olden et al. (2004) which results in a feature relevance score for each input
variable. The basic idea is to multiply up all path weights for each
possible connection between an input feature and the output and then
calculate the sum over them. Besides, it is a global interpretation method
and independent of the input data. For a neural network with \eqn{3} hidden
layers with weight matrices \eqn{W_1}, \eqn{W_2} and \eqn{W_3} this method
results in a simple matrix multiplication
\deqn{W_1 * W_2 * W_3. }
}
\examples{

#----------------------- Example 1: Neuralnet ------------------------------
library(neuralnet)
data(iris)

# Train a Neural Network
nn <- neuralnet((Species == "setosa") ~ Petal.Length + Petal.Width,
  iris,
  linear.output = FALSE,
  hidden = c(3, 2), act.fct = "tanh", rep = 1
)

# Convert the trained model
converter <- Converter$new(nn)

# Apply the Connection Weights method
cw <- ConnectionWeights$new(converter)

# Get the result as a torch tensor
cw$get_result(type = "torch.tensor")

# Plot the result
plot(cw)

#----------------------- Example 2: Keras ----------------------------------
library(keras)

# Define a model
model <- keras_model_sequential()
model \%>\%
  layer_conv_1d(
    input_shape = c(64, 3), kernel_size = 16, filters = 8,
    activation = "softplus"
  ) \%>\%
  layer_conv_1d(kernel_size = 16, filters = 4, activation = "tanh") \%>\%
  layer_conv_1d(kernel_size = 16, filters = 2, activation = "relu") \%>\%
  layer_flatten() \%>\%
  layer_dense(units = 64, activation = "relu") \%>\%
  layer_dense(units = 2, activation = "softmax")

# Convert the model
converter <- Converter$new(model)

# Apply the Connection Weights method
cw <- ConnectionWeights$new(converter)

# Get the result as data.frame
cw$get_result(type = "data.frame")

# Plot the result for all classes
plot(cw, class_id = 1:2)
}
\references{
\itemize{
\item J. D. Olden et al. (2004) \emph{An accurate comparison of methods for
quantifying variable importance in artificial neural networks using
simulated data.} Ecological Modelling 178, p. 389â€“397
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{converter}}{The converter of class \link{Converter} with the stored and
torch-converted model.}

\item{\code{channels_first}}{The data format of the result, i.e. channels on
last dimension (\code{FALSE}) or on the first dimension (\code{TRUE}). If the
data has no channels, use the default value \code{TRUE}.}

\item{\code{dtype}}{The type of the data and parameters (either \code{'float'}
for \link[torch:torch_dtype]{torch::torch_float} or \code{'double'} for \link[torch:torch_dtype]{torch::torch_double}).}

\item{\code{result}}{The methods result as a torch tensor of size
(dim_in, dim_out).}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ConnectionWeights$new()}}
\item \href{#method-get_result}{\code{ConnectionWeights$get_result()}}
\item \href{#method-plot}{\code{ConnectionWeights$plot()}}
\item \href{#method-clone}{\code{ConnectionWeights$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConnectionWeights$new(converter, channels_first = TRUE, dtype = "float")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{converter}}{The converter of class \link{Converter} with the stored and
torch-converted model.}

\item{\code{channels_first}}{The data format of the result, i.e. channels on
last dimension (\code{FALSE}) or on the first dimension (\code{TRUE}). If the
data has no channels, use the default value \code{TRUE}.}

\item{\code{dtype}}{The type of the data and parameters
(either \code{'float'} or \code{'double'}).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_result"></a>}}
\if{latex}{\out{\hypertarget{method-get_result}{}}}
\subsection{Method \code{get_result()}}{
This function returns the result of the Connection Weights method either
as an array (\code{as_torch = FALSE}) or a torch tensor (\code{as_torch = TRUE})
of size (dim_in, dim_out).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConnectionWeights$get_result(type = "array")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{as_torch}}{Boolean value whether the output is an array or a torch
tensor.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The result of this method.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConnectionWeights$plot(class_id = 1, aggr_channels = sum)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConnectionWeights$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
